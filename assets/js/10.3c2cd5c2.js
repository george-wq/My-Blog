(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{213:function(e,t,s){"use strict";s.r(t);var n=s(0),a=Object(n.a)({},(function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[s("h1",{attrs:{id:"react-hooks"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#react-hooks"}},[e._v("#")]),e._v(" React Hooks")]),e._v(" "),s("blockquote",[s("p",[e._v("Hook 是 React 16.8 的新增特性。它是函数式组件，它可以让你在不编写 class 的情况下使用 state 以及其他的 React 特性。")])]),e._v(" "),s("p",[e._v("在 react hook中我们需要理解它的数据(state、props)和生命周期。useState Hook && useEffect Hook")]),e._v(" "),s("h3",{attrs:{id:"组件类的缺点"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#组件类的缺点"}},[e._v("#")]),e._v(" 组件类的缺点")]),e._v(" "),s("p",[e._v("React 的核心是组件。v16.8 版本之前，组件的标准写法是类（class）。下面是一个简单的组件类。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('import React, { Component } from "react";\n\nexport default class Button extends Component {\n  constructor() {\n    super();\n    this.state = { buttonText: "Click me, please" };\n    this.handleClick = this.handleClick.bind(this);\n  }\n  handleClick() {\n    this.setState(() => {\n      return { buttonText: "Thanks, been clicked!" };\n    });\n  }\n  render() {\n    const { buttonText } = this.state;\n    return <button onClick={this.handleClick}>{buttonText}</button>;\n  }\n}\n')])])]),s("p",[e._v('这个组件类仅仅是一个按钮，但可以看到，它的代码已经很"重"了。真实的 React App 由多个类按照层级，一层层构成，复杂度成倍增长。再加入 Redux，就变得更复杂。')]),e._v(" "),s("p",[e._v("Redux 的作者 Dan Abramov 总结了组件类的几个缺点。")]),e._v(" "),s("ul",[s("li",[e._v("大型组件很难拆分和重构，也很难测试。")]),e._v(" "),s("li",[e._v("业务逻辑分散在组件的各个方法之中，导致重复逻辑或关联逻辑。")]),e._v(" "),s("li",[e._v("组件类引入了复杂的编程模式，比如 render props 和高阶组件。")])]),e._v(" "),s("h3",{attrs:{id:"函数组件"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#函数组件"}},[e._v("#")]),e._v(" 函数组件")]),e._v(" "),s("p",[e._v("React 团队希望，组件不要变成复杂的容器，最好只是数据流的管道。开发者根据需要，组合管道即可。 组件的最佳写法应该是函数，而不是类。")]),e._v(" "),s("p",[e._v("React 早就支持函数组件，下面就是一个例子。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("function Welcome(props) {\n  return <h1>Hello, {props.name}</h1>;\n}\n")])])]),s("p",[e._v("但是，这种写法有重大限制，必须是纯函数，不能包含状态，也不支持生命周期方法，因此无法取代类。")]),e._v(" "),s("p",[e._v('React Hooks 的设计目的，就是加强版函数组件，完全不使用"类"，就能写出一个全功能的组件。')]),e._v(" "),s("h3",{attrs:{id:"hook-的含义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#hook-的含义"}},[e._v("#")]),e._v(" Hook 的含义")]),e._v(" "),s("p",[e._v('Hook 这个单词的意思是"钩子"。')]),e._v(" "),s("p",[e._v('React Hooks 的意思是，组件尽量写成纯函数，如果需要外部功能和副作用，就用钩子把外部代码"钩"进来。 React Hooks 就是那些钩子。')]),e._v(" "),s("p",[e._v("你需要什么功能，就使用什么钩子。React 默认提供了一些常用钩子，你也可以封装自己的钩子。")]),e._v(" "),s("p",[e._v("所有的钩子都是为函数引入外部功能，所以 React 约定，钩子一律使用use前缀命名，便于识别。你要使用 xxx 功能，钩子就命名为 usexxx。")]),e._v(" "),s("p",[e._v("下面介绍 React 默认提供的四个最常用的钩子。")]),e._v(" "),s("ul",[s("li",[e._v("useState()")]),e._v(" "),s("li",[e._v("useContext()")]),e._v(" "),s("li",[e._v("useReducer()")]),e._v(" "),s("li",[e._v("useEffect()")])]),e._v(" "),s("h3",{attrs:{id:"在react-hook中如何定义状态、修改状态、传入初始状态、生命周期"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#在react-hook中如何定义状态、修改状态、传入初始状态、生命周期"}},[e._v("#")]),e._v(" 在react hook中如何定义状态、修改状态、传入初始状态、生命周期")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("import React, { useState, useEffect } from 'react';\n\nconst App = () => {\n  const [ value1, setvalue1 ] = useState(0);\n  const [ value2, setvalue2 ] = useState(100);\n  \n  useEffect(() => { \n    // 类似于 componentDidMount && componentDidUpdate\n    console.log('hello') \n    // 类似于 componentWillUnmount \n    return () => {\n      console.log('hello world!');\n    }\n  });\n\n  return (\n    <div>\n      <div>{value1}</div>\n      <div>{value2}</div>\n      <button onClick={(e) => setvalue1(value1 + 1)}>add</button>\n      <button onClick={(e) => setvalue2(value2 - 1)}>remove</button>\n    </div>\n  )\n}\n\nexport default App;\n")])])]),s("h3",{attrs:{id:"usecontext-：共享状态钩子"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#usecontext-：共享状态钩子"}},[e._v("#")]),e._v(" useContext()：共享状态钩子")]),e._v(" "),s("p",[e._v("如果需要在组件之间共享状态，可以使用useContext()")]),e._v(" "),s("p",[e._v("现在有两个组件 Navbar 和 Messages，我们希望它们之间共享状态。")]),e._v(" "),s("p",[e._v("第一步就是使用 React Context API，在组件外部建立一个 Context")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const AppContext = React.createContext({});\n")])])]),s("p",[e._v("组件封装代码如下")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("<AppContext.Provider value={{\n  username: 'superawesome'\n}}>\n  <div className=\"App\">\n    <Navbar/>\n    <Messages/>\n  </div>\n</AppContext.Provider>\n")])])]),s("p",[e._v("上面代码中，AppContext.Provider提供了一个 Context 对象，这个对象可以被子组件共享。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('const Navbar = () => {\n  const { username } = useContext(AppContext);\n  return (\n    <div className="navbar">\n      <p>AwesomeSite</p>\n      <p>{username}</p>\n    </div>\n  );\n}\n')])])]),s("p",[e._v("上面代码中，useContext()钩子函数用来引入 Context 对象，从中获取username属性。")]),e._v(" "),s("p",[e._v("Message 组件的代码也类似。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v('const Messages = () => {\n  const { username } = useContext(AppContext)\n\n  return (\n    <div className="messages">\n      <h1>Messages</h1>\n      <p>1 message for {username}</p>\n      <p className="message">useContext is awesome!</p>\n    </div>\n  )\n}\n')])])]),s("h3",{attrs:{id:"usereducer-：action-钩子"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#usereducer-：action-钩子"}},[e._v("#")]),e._v(" useReducer()：action 钩子")]),e._v(" "),s("p",[e._v("React 本身不提供状态管理功能，通常需要使用外部库。这方面最常用的库是 Redux。")]),e._v(" "),s("p",[e._v("Redux 的核心概念是，组件发出 action 与状态管理器通信。状态管理器收到 action 以后，使用 Reducer 函数算出新的状态，Reducer 函数的形式是(state, action) => newState。")]),e._v(" "),s("p",[e._v("useReducers()钩子用来引入 Reducer 功能。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const [state, dispatch] = useReducer(reducer, initialState);\n")])])]),s("p",[e._v("上面是useReducer()的基本用法，它接受 Reducer 函数和状态的初始值作为参数，返回一个数组。数组的第一个成员是状态的当前值，第二个成员是发送 action 的dispatch函数。")]),e._v(" "),s("p",[e._v("下面是一个计数器的例子。用于计算状态的 Reducer 函数如下。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const myReducer = (state, action) => {\n  switch(action.type)  {\n    case('countUp'):\n      return  {\n        ...state,\n        count: state.count + 1\n      }\n    default:\n      return  state;\n  }\n}\n")])])]),s("p",[e._v("组件代码如下。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const App = () => {\n  const [state, dispatch] = useReducer(myReducer, { count:   0 });\n  return  (\n    <div className=\"App\">\n      <button onClick={() => dispatch({ type: 'countUp' })}>\n        +1\n      </button>\n      <p>Count: {state.count}</p>\n    </div>\n  );\n}\n")])])]),s("p",[e._v("由于 Hooks 可以提供共享状态和 Reducer 函数，所以它在这些方面可以取代 Redux。但是，它没法提供中间件（middleware）和时间旅行（time travel），如果你需要这两个功能，还是要用 Redux。")]),e._v(" "),s("h3",{attrs:{id:"创建自己的-hooks"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#创建自己的-hooks"}},[e._v("#")]),e._v(" 创建自己的 Hooks")]),e._v(" "),s("p",[e._v("上例的 Hooks 代码还可以封装起来，变成一个自定义的 Hook，便于共享。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const usePerson = (personId) => {\n  const [loading, setLoading] = useState(true);\n  const [person, setPerson] = useState({});\n  useEffect(() => {\n    setLoading(true);\n    fetch(`https://swapi.co/api/people/${personId}/`)\n      .then(response => response.json())\n      .then(data => {\n        setPerson(data);\n        setLoading(false);\n      });\n  }, [personId]);  \n  return [loading, person];\n};\n")])])]),s("p",[e._v("上面代码中，usePerson()就是一个自定义的 Hook。")]),e._v(" "),s("p",[e._v("Person 组件就改用这个新的钩子，引入封装的逻辑。")]),e._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[e._v("const Person = ({ personId }) => {\n  const [loading, person] = usePerson(personId);\n\n  if (loading === true) {\n    return <p>Loading...</p>;\n  }\n\n  return (\n    <div>\n      <p>You're viewing: {person.name}</p>\n      <p>Height: {person.height}</p>\n      <p>Mass: {person.mass}</p>\n    </div>\n  );\n};\n")])])]),s("p",[s("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2019/09/react-hooks.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("React Hooks 教程"),s("OutboundLink")],1),e._v(" "),s("a",{attrs:{href:"https://github.com/brickspert/blog/issues/26",target:"_blank",rel:"noopener noreferrer"}},[e._v("React Hooks 原理"),s("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=a.exports}}]);